<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Objective Question Self-Practice</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- html2canvas CDN for converting HTML to canvas/image (for PDF generation) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- jsPDF CDN for generating PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* Base styles for body and container */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to the top for better scrolling */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            position: relative; /* Needed for floating button positioning */
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10; /* Ensure container is above modal background */
        }

        /* Generic button styles */
        .btn {
            padding: 12px 25px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            text-align: center;
        }
        .btn-primary {
            background-color: #6366f1;
            color: #ffffff;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
        }
        .btn-primary:active {
            transform: translateY(0);
        }

        /* Question card styling */
        .question-card {
            background-color: #f9fafb;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            margin-bottom: 15px;
        }
        .question-card p.question-text {
            font-size: 1.15rem;
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 15px;
        }
        .question-card .option label {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .question-card .option label:hover {
            background-color: #eff6ff;
            border-color: #a7b4f5;
        }
        .question-card .option input[type="radio"] {
            margin-right: 12px;
            accent-color: #6366f1; /* Custom color for radio button */
            transform: scale(1.2); /* Slightly larger radio button */
        }

        /* Loading spinner animation */
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #6366f1;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none; /* Hidden by default, shown by JS */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Results section styling */
        .results-section {
            background-color: #ecfdf5; /* Light green background */
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #a7f3d0; /* Green border */
            text-align: center;
            display: none; /* Hidden by default, shown by JS */
        }
        .results-section h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #065f46; /* Dark green text */
            margin-bottom: 10px;
        }
        .results-section p {
            font-size: 1.1rem;
            color: #065f46;
        }

        /* Error message styling */
        .error-message {
            color: #ef4444; /* Red color for errors */
            background-color: #fee2e2;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #fca5a5;
            margin-top: 15px;
            display: none; /* Hidden by default, shown by JS */
            font-weight: 500;
        }

        /* Floating button specific styles */
        .floating-button {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background-color: #6366f1;
            color: #ffffff;
            font-weight: 800;
            padding: 16px 32px;
            border-radius: 9999px;
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.4);
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            z-index: 50;
        }
        .floating-button:hover {
            background-color: #4f46e5;
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 15px 30px rgba(99, 102, 241, 0.5);
        }
        .floating-button:active {
            transform: translateY(0);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3);
        }
        .floating-button svg {
            width: 24px;
            height: 24px;
            margin-right: 8px;
        }

        /* Modal overlay and content styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 60;
            opacity: 0; /* Initial opacity for fadeIn animation */
            animation: fadeIn 0.3s ease-out forwards;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 32px;
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 448px;
            transform: translateY(20px) scale(0.95);
            animation: slideUp 0.3s ease-out forwards;
            position: relative;
            z-index: 70;
        }
        .modal-content h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 24px;
            text-align: center;
        }
        /* Input group labels in modal */
        .modal-content .input-group label {
            font-size: 1.125rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            display: block;
        }
        /* Input group fields in modal */
        .modal-content .input-group input,
        .modal-content .input-group select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 12px;
            font-size: 1rem;
            color: #4b5563;
            transition: border-color 0.2s ease;
        }
        .modal-content .input-group input:focus, .modal-content .input-group select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }
        /* Modal buttons container */
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 16px;
            margin-top: 28px;
        }
        /* Cancel button in modal */
        .btn-cancel {
            background-color: #e5e7eb;
            color: #374151;
            font-weight: 600;
            padding: 12px 24px;
            border-radius: 12px;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .btn-cancel:hover {
            background-color: #d1d5db;
        }
        /* Generate button in modal */
        .btn-generate {
            background-color: #10b981;
            color: #ffffff;
            font-weight: 800;
            padding: 12px 24px;
            border-radius: 12px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.3);
        }
        .btn-generate:hover {
            background-color: #059669;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 15px rgba(16, 185, 129, 0.4);
        }

        /* Timer and Score display box */
        .timer-score-box {
            background-color: #e0f2fe;
            padding: 16px;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }
        .timer-score-box .label {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e40af;
        }
        .timer-score-box .value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        /* Styling for correct/incorrect/unanswered question cards */
        .question-card.correct {
            border-color: #10B981; /* green-500 */
            background-color: #ECFDF5; /* green-50 */
        }
        .question-card.incorrect {
            border-color: #EF4444; /* red-500 */
            background-color: #FEE2E2; /* red-50 */
        }
        .question-card.unanswered {
            border-color: #F59E0B; /* yellow-500 */
            background-color: #FFFBEB; /* yellow-50 */
        }

        /* Styling for correct/incorrect options within question cards */
        .option label.correct-option {
            background-color: #D1FAE5 !important; /* light green */
            border-color: #34D399 !important; /* green-400 */
            font-weight: 600;
        }
        .option label.selected-incorrect-option {
            background-color: #FEE2E2 !important; /* light red */
            border-color: #EF4444 !important; /* red-400 */
            font-weight: 600;
        }

        /* Elements to hide during PDF generation */
        .hide-on-pdf {
            /* This class will be programmatically controlled by JS to hide elements
               like buttons, timer, and modal during PDF capture. */
        }

        /* CSS animations for modal transitions */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideUp {
            from { transform: translateY(20px) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container" id="main-content-for-pdf">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">📝 Objective Question Generator</h1>

        <!-- Timer and Score Display - Hidden by default, shown when quiz starts -->
        <div id="timer-score-display" class="timer-score-box hidden hide-on-pdf">
            <div class="label">
                Time Left: <span id="time-left" class="value text-blue-800">00:00</span>
            </div>
            <div id="quiz-score-summary" class="label hidden">
                Your Score: <span id="score-value" class="value text-purple-800">0 / 0</span>
            </div>
        </div>

        <!-- Initial Message - Visible on page load until quiz is generated -->
        <div id="initial-message" class="text-center py-12">
            <p class="text-xl text-gray-500 font-medium">
                Click the "Create Quiz" button to generate a new quiz!
            </p>
            <p class="mt-2 text-md text-gray-400">
                You can specify the topic and number of questions.
            </p>
        </div>

        <!-- Loading Indicator - Shown while fetching questions from API -->
        <div id="loading-spinner" class="loading-spinner"></div>

        <!-- Error Message Display - Shown if API call fails or inputs are invalid -->
        <div id="error-message" class="error-message">
            <strong class="font-bold">Error!</strong>
            <span id="error-text" class="block sm:inline ml-2"></span>
        </div>

        <!-- Quiz Questions Area - Dynamically populated by JavaScript -->
        <div id="quiz-questions-area" class="mt-5">
            <!-- Questions will be loaded here -->
        </div>

        <!-- Submit Quiz Button - Hidden by default, shown when quiz questions are loaded -->
        <div id="submit-quiz-button-container" class="flex justify-center mt-4 hidden hide-on-pdf">
            <button id="submit-quiz-btn" class="btn btn-primary w-full max-w-xs">Submit Answers</button>
        </div>

        <!-- Quiz Result and Action Buttons - Hidden by default, shown after quiz submission -->
        <div id="quiz-result-actions" class="results-section mt-5 hidden">
            <h2 class="text-3xl font-bold text-gray-900">Quiz Completed!</h2>
            <p id="final-score-text" class="text-xl font-bold text-green-600 mb-4"></p>
            <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 hide-on-pdf">
                <button id="create-new-quiz-btn" class="btn btn-primary bg-blue-600 hover:bg-blue-700 w-full sm:w-auto">
                    Create New Quiz
                </button>
                <button id="download-quiz-btn" class="btn btn-primary bg-gray-700 hover:bg-gray-800 w-full sm:w-auto">
                    Download Quiz (PDF)
                </button>
            </div>
        </div>
    </div>

    <!-- Floating Create Quiz Button - Always visible, triggers modal -->
    <button id="floating-create-quiz-btn" class="floating-button hide-on-pdf">
        <svg class="w-6 h-6 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
        Create Quiz
    </button>

    <!-- Quiz Generation Modal - Hidden by default, shown on button click -->
    <div id="quiz-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-3xl font-bold text-gray-900 mb-6 text-center">Generate New Quiz</h2>

            <div class="input-group mb-5">
                <label for="modal-topic-input">Quiz Topic:</label>
                <input
                    type="text"
                    id="modal-topic-input"
                    placeholder="e.g., World History, Science, JavaScript"
                    class="focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500"
                    autofocus
                />
            </div>

            <div class="input-group mb-7">
                <label for="modal-num-questions-select">Number of Questions:</label>
                <select
                    id="modal-num-questions-select"
                    class="focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500"
                >
                    <option value="10">10 Questions</option>
                    <option value="20">20 Questions</option>
                    <option value="30">30 Questions</option>
                    <option value="40">40 Questions</option>
                    <option value="50">50 Questions</option>
                    <option value="60">60 Questions</option>
                    <option value="70">70 Questions</option>
                    <option value="80">80 Questions</option>
                    <option value="90">90 Questions</option>
                    <option value="100">100 Questions</option>
                </select>
            </div>

            <div class="modal-buttons">
                <button id="cancel-quiz-btn" class="btn-cancel">
                    Cancel
                </button>
                <button id="generate-quiz-modal-btn" class="btn-generate">
                    Generate Quiz
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        // Main container for PDF capture
        const mainContentForPdf = document.getElementById('main-content-for-pdf');
        // Elements for initial state and loading/error feedback
        const initialMessage = document.getElementById('initial-message');
        const loadingSpinner = document.getElementById('loading-spinner');
        const errorMessageDiv = document.getElementById('error-message');
        const errorTextSpan = document.getElementById('error-text');
        // Elements for quiz display and interaction
        const quizQuestionsArea = document.getElementById('quiz-questions-area');
        const submitQuizBtnContainer = document.getElementById('submit-quiz-button-container');
        const submitQuizBtn = document.getElementById('submit-quiz-btn');
        const quizResultActions = document.getElementById('quiz-result-actions');
        const finalScoreText = document.getElementById('final-score-text');
        // Floating button and modal elements
        const floatingCreateQuizBtn = document.getElementById('floating-create-quiz-btn');
        const quizModal = document.getElementById('quiz-modal');
        const modalTopicInput = document.getElementById('modal-topic-input');
        const modalNumQuestionsSelect = document.getElementById('modal-num-questions-select');
        const cancelQuizBtn = document.getElementById('cancel-quiz-btn');
        const generateQuizModalBtn = document.getElementById('generate-quiz-modal-btn');
        // Timer and score display elements
        const timerScoreDisplay = document.getElementById('timer-score-display');
        const timeLeftSpan = document.getElementById('time-left');
        const quizScoreSummary = document.getElementById('quiz-score-summary');
        const scoreValueSpan = document.getElementById('score-value');
        // Post-quiz action buttons
        const createNewQuizBtn = document.getElementById('create-new-quiz-btn');
        const downloadQuizBtn = document.getElementById('download-quiz-btn');

        // --- Global Quiz State Variables ---
        let quizData = [];              // Stores the fetched quiz questions and correct answers
        let selectedAnswers = {};       // Stores user's selected answers {questionIndex: "Selected Option Text"}
        let quizSubmitted = false;      // True if the quiz has been submitted
        let score = 0;                  // User's current score
        let timeLeft = 0;               // Time remaining in seconds
        let quizActive = false;         // True if the quiz is currently running (timer active, inputs enabled)
        let timerIntervalId = null;     // ID for the timer interval (used to clear it)
        let currentQuizTopic = '';      // Stores the quiz topic for naming the PDF file

        // --- Utility Functions ---

        /**
         * Formats a given number of seconds into a "MM:SS" string.
         * @param {number} seconds - The total number of seconds.
         * @returns {string} The formatted time string (e.g., "05:30").
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        /**
         * Displays an error message to the user in the designated error area.
         * @param {string} message - The error message to display.
         */
        function displayError(message) {
            errorMessageDiv.classList.remove('hidden');
            errorTextSpan.textContent = message;
        }

        /**
         * Hides the error message area.
         */
        function hideError() {
            errorMessageDiv.classList.add('hidden');
            errorTextSpan.textContent = '';
        }

        /**
         * Displays the loading spinner and prepares the UI for loading content.
         */
        function showLoading() {
            loadingSpinner.style.display = 'block';
            initialMessage.classList.add('hidden');
            quizQuestionsArea.innerHTML = ''; // Clear any previously loaded questions
            submitQuizBtnContainer.classList.add('hidden');
            quizResultActions.classList.add('hidden');
            timerScoreDisplay.classList.add('hidden');
            quizScoreSummary.classList.add('hidden');
        }

        /**
         * Hides the loading spinner.
         */
        function hideLoading() {
            loadingSpinner.style.display = 'none';
        }

        // --- Modal and UI State Management ---

        /**
         * Displays the quiz generation modal. Resets its input fields and sets focus.
         */
        function showCreateQuizModal() {
            quizModal.classList.remove('hidden');
            quizModal.style.display = 'flex'; // Explicitly set display to flex for modal overlay
            modalTopicInput.value = '';
            modalNumQuestionsSelect.value = '10';
            modalTopicInput.focus();
        }

        /**
         * Hides the quiz generation modal.
         */
        function hideCreateQuizModal() {
            quizModal.classList.add('hidden');
            quizModal.style.display = ''; // Remove inline display style to allow CSS rules to take over
        }

        /**
         * Resets all quiz-related state variables and UI elements to their initial state.
         * This prepares the application for a new quiz.
         */
        function resetQuizApp() {
            quizData = [];
            selectedAnswers = {};
            quizSubmitted = false;
            score = 0;
            timeLeft = 0;
            quizActive = false;
            if (timerIntervalId) {
                clearInterval(timerIntervalId);
                timerIntervalId = null;
            }
            currentQuizTopic = '';

            hideError();
            hideLoading();
            quizQuestionsArea.innerHTML = '';
            initialMessage.classList.remove('hidden'); // Show the "Click to create quiz" message
            submitQuizBtnContainer.classList.add('hidden');
            quizResultActions.classList.add('hidden');
            timerScoreDisplay.classList.add('hidden');
            quizScoreSummary.classList.add('hidden');
            timeLeftSpan.textContent = '00:00'; // Reset timer display
            scoreValueSpan.textContent = '0 / 0'; // Reset score display
            finalScoreText.textContent = ''; // Clear final score text
        }

        // --- Timer Logic ---

        /**
         * Starts the quiz countdown timer.
         * The timer stops automatically when `timeLeft` reaches 0 or `handleSubmitQuiz` is called.
         */
        function startTimer() {
            if (timerIntervalId) clearInterval(timerIntervalId); // Clear any existing timer to prevent multiple timers running
            timerScoreDisplay.classList.remove('hidden'); // Show the timer display area
            timeLeftSpan.textContent = formatTime(timeLeft); // Update with initial time

            timerIntervalId = setInterval(() => {
                timeLeft--;
                timeLeftSpan.textContent = formatTime(timeLeft); // Update timer text every second
                if (timeLeft <= 0) {
                    clearInterval(timerIntervalId); // Stop the timer
                    timerIntervalId = null;
                    if (quizActive) { // If quiz was active when timer ran out, submit answers
                        handleSubmitQuiz();
                    }
                }
            }, 1000); // Interval of 1 second (1000 milliseconds)
        }

        // --- Quiz Interaction Functions ---

        /**
         * Handles a user's selection of an option for a specific question.
         * Updates the `selectedAnswers` state and re-renders the questions for visual feedback.
         * @param {number} questionIndex - The zero-based index of the question.
         * @param {string} option - The text of the option selected by the user.
         */
        function handleOptionSelect(questionIndex, option) {
            // Allow selection only if the quiz is active and not yet submitted
            if (quizActive && !quizSubmitted) {
                selectedAnswers[questionIndex] = option; // Store the user's choice
                renderQuizQuestions(); // Re-render to highlight the selected option
            }
        }

        /**
         * Dynamically renders the quiz questions and their options based on the `quizData`.
         * Applies visual styling for selected answers and correctness after quiz submission.
         */
        function renderQuizQuestions() {
            quizQuestionsArea.innerHTML = ''; // Clear any existing questions to prevent duplicates
            if (!quizData || quizData.length === 0) return; // Exit if no quiz data

            quizData.forEach((q, index) => {
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card'; // Apply base styling
                questionCard.innerHTML = `
                    <p class="question-text">${index + 1}. ${q.questionText}</p>
                    <div class="options-group"></div>
                `;
                const optionsGroup = questionCard.querySelector('.options-group');

                q.options.forEach((option, optIndex) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option';

                    const radioId = `q${index}-option${optIndex}`;
                    const inputElement = document.createElement('input');
                    inputElement.type = 'radio';
                    inputElement.name = `question${index}`; // Group radio buttons by question
                    inputElement.value = option;
                    inputElement.id = radioId;
                    inputElement.className = 'mr-3 accent-indigo-600 transform scale-125';

                    const labelElement = document.createElement('label');
                    labelElement.htmlFor = radioId;
                    labelElement.className = 'flex items-center p-3 bg-white border border-gray-300 rounded-md cursor-pointer transition-all duration-200';
                    labelElement.innerHTML = `${String.fromCharCode(65 + optIndex)}. ${option}`; // Display option letter (A, B, C...)

                    // Add event listener to the label to ensure clicking the whole label selects the radio
                    labelElement.addEventListener('click', () => {
                        inputElement.checked = true; // Manually check the radio button
                        handleOptionSelect(index, option); // Call our option selection handler
                    });

                    // Set radio button as checked if it matches the user's previously selected answer
                    if (selectedAnswers[index] === option) {
                        inputElement.checked = true;
                    }

                    // Disable radio buttons if the quiz is not active or has been submitted
                    if (!quizActive || quizSubmitted) {
                        inputElement.disabled = true;
                        labelElement.classList.add('opacity-70', 'cursor-not-allowed'); // Reduce opacity and change cursor
                    } else {
                         labelElement.classList.remove('opacity-70', 'cursor-not-allowed');
                    }

                    // Post-submission feedback: Apply specific classes for correct/incorrect visual cues
                    if (quizSubmitted) {
                        if (option === q.correctAnswer) { // Check against the correct answer from quizData
                            labelElement.classList.add('correct-option');
                            labelElement.innerHTML += ' <span class="ml-auto text-green-600">✓ Correct</span>';
                        } else if (selectedAnswers[index] === option && selectedAnswers[index] !== q.correctAnswer) {
                            labelElement.classList.add('selected-incorrect-option');
                            labelElement.innerHTML += ' <span class="ml-auto text-red-600">✗ Your Answer</span>';
                        }
                    }

                    optionDiv.appendChild(inputElement);
                    optionDiv.appendChild(labelElement);
                    optionsGroup.appendChild(optionDiv);
                });

                // Add overall question card border feedback after submission
                if (quizSubmitted) {
                    const hasAnswered = selectedAnswers[index] !== undefined;
                    const isCorrectOverall = selectedAnswers[index] === q.correctAnswer;

                    if (hasAnswered) {
                        if (isCorrectOverall) {
                            questionCard.classList.add('correct'); // Green border
                        } else {
                            questionCard.classList.add('incorrect'); // Red border
                        }
                    } else {
                        questionCard.classList.add('unanswered'); // Yellow border
                    }
                }

                quizQuestionsArea.appendChild(questionCard);
            });

            // Show submit button if quiz is active and there are questions
            if (quizActive && !quizSubmitted && quizData.length > 0) {
                submitQuizBtnContainer.classList.remove('hidden');
            } else {
                submitQuizBtnContainer.classList.add('hidden');
            }
        }

        /**
         * Calculates the final quiz score, stops the timer, and displays the results section.
         */
        function handleSubmitQuiz() {
            if (quizSubmitted) return; // Prevent multiple submissions
            quizActive = false; // Deactivate the quiz
            quizSubmitted = true; // Mark as submitted
            if (timerIntervalId) {
                clearInterval(timerIntervalId); // Stop the timer
                timerIntervalId = null;
            }

            let newScore = 0;
            quizData.forEach((q, index) => {
                if (selectedAnswers[index] === q.correctAnswer) { // Check against correct answer
                    newScore += 1;
                }
            });
            score = newScore; // Update the global score

            renderQuizQuestions(); // Re-render questions to show correct/incorrect answers and disable inputs

            // Display final score and action buttons in the results section
            finalScoreText.textContent = `You scored ${score} out of ${quizData.length}!`;
            quizResultActions.classList.remove('hidden');

            // Update score display at the top of the container as well
            quizScoreSummary.classList.remove('hidden');
            scoreValueSpan.textContent = `${score} / ${quizData.length}`;

            // Scroll the user to the results section for better visibility
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }

        // --- API Call and Quiz Generation ---

        /**
         * Calls the Vercel proxy to generate quiz questions based on user input.
         * Handles loading states, errors, and initiates timer/quiz display upon success.
         */
        async function generateQuestions() {
            const topic = modalTopicInput.value.trim();
            const numQuestions = parseInt(modalNumQuestionsSelect.value);

            if (!topic) {
                displayError('Please enter a quiz topic.');
                return;
            }

            currentQuizTopic = topic; // Store topic for PDF filename
            hideCreateQuizModal(); // Close the modal
            hideError();          // Clear any previous errors
            showLoading();        // Show loading spinner
            initialMessage.classList.add('hidden'); // Hide the initial welcome message

            // IMPORTANT: Replace 'YOUR_VERCEL_API_ENDPOINT_URL_HERE' with the FULL URL to your Vercel serverless function.
            // Example: If your Vercel app is 'https://my-quiz-app.vercel.app/' and your API is in 'api/generate-quiz.js',
            // then proxyUrl should be 'https://my-quiz-app.vercel.app/api/generate-quiz'
            const proxyUrl = 'YOUR_VERCEL_API_ENDPOINT_URL_HERE'; // <<<--- !!! IMPORTANT: REPLACE THIS URL !!!

            try {
                // Make the API call to your Vercel proxy
                const response = await fetchWithExponentialBackoff(proxyUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // Send topic and numQuestions. Your proxy will use these to build the Gemini prompt.
                    body: JSON.stringify({
                        topic: topic,
                        numQuestions: numQuestions
                    })
                });

                const result = await response.json(); // Parse the JSON response from your proxy

                // Log the response from your proxy for debugging purposes in the browser console.
                // This is crucial if questions don't appear, to check the actual JSON structure.
                console.log("Response from Vercel proxy:", result);

                if (response.ok) { // If the proxy's response indicates success (HTTP 2xx status)
                    // The proxy should return an array of question objects.
                    // Assuming structure: [{questionText: "...", options: [...], correctAnswer: "..."}]
                    if (Array.isArray(result) && result.length > 0) {
                        quizData = result; // Store the fetched quiz data
                        selectedAnswers = {}; // Reset user selections for the new quiz
                        quizSubmitted = false; // Reset submission status
                        score = 0;            // Reset score
                        timeLeft = numQuestions * 30; // Set timer: 30 seconds per question (adjust as needed)
                        quizActive = true;    // Activate the quiz
                        renderQuizQuestions(); // Display the questions on the UI
                        startTimer();         // Start the countdown timer
                        initialMessage.classList.add('hidden'); // Ensure initial message stays hidden
                    } else {
                        throw new Error(result.error || 'Proxy returned an empty or invalid array of questions. Check your proxy function and Gemini response format.');
                    }
                } else {
                    // If the proxy returns an error status (e.g., 400, 500)
                    throw new Error(result.error || `Proxy server error: ${response.status}. Check your Vercel logs.`);
                }
            } catch (error) {
                console.error('Error generating questions via proxy:', error);
                displayError(`Failed to generate questions: ${error.message}. Please check your Vercel API endpoint URL and your proxy serverless function.`);
                quizData = null; // Clear quiz data on error
            } finally {
                hideLoading(); // Always hide loading spinner
            }
        }

        /**
         * Utility function for making fetch requests with exponential backoff for retries.
         * Helps handle temporary network issues or rate limits gracefully.
         * @param {string} url - The URL to fetch from.
         * @param {object} options - Fetch options (method, headers, body, etc.).
         * @param {number} retries - Maximum number of retries (default: 5).
         * @param {number} delay - Initial delay between retries in milliseconds (default: 1000).
         * @returns {Promise<Response>} The fetch response object.
         * @throws {Error} If all retries are exhausted or a non-retryable HTTP error occurs.
         */
        async function fetchWithExponentialBackoff(url, options, retries = 5, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        return response; // Success, return response
                    } else if (response.status === 429 || response.status >= 500) { // Retry for rate limits (429) or server errors (5xx)
                        console.warn(`Attempt ${i + 1} failed with status ${response.status}. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay)); // Wait for delay
                        delay *= 2; // Double the delay for the next retry
                    } else {
                        // For other client errors (e.g., 400 Bad Request, 404 Not Found), don't retry, just throw
                        const errorData = await response.json().catch(() => ({})); // Try to parse error response, default to empty object
                        throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                    }
                } catch (error) {
                    if (i === retries - 1) {
                        throw error; // Throw if all retries are exhausted
                    }
                    console.error(`Fetch error on attempt ${i + 1}:`, error.message);
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
            throw new Error('Max retries exceeded'); // Should not be reached if an error was thrown or response was ok
        }

        // --- PDF Download Function ---

        /**
         * Downloads the currently displayed quiz content (questions and options) as a PDF document.
         * It temporarily hides UI elements not relevant to the PDF before capturing the content.
         */
        function downloadQuizAsPdf() {
            if (!quizData || quizData.length === 0) {
                displayError("No quiz to download. Please generate a quiz first.");
                return;
            }

            // Select all elements that should be hidden in the PDF (e.g., buttons, timer)
            const elementsToHide = document.querySelectorAll('.hide-on-pdf');
            const originalDisplays = []; // Store original display styles to restore later

            // Hide elements before capturing the content
            elementsToHide.forEach(el => {
                originalDisplays.push({ el: el, display: el.style.display }); // Save original style
                el.style.display = 'none'; // Hide the element
            });

            // Use a small timeout to allow the browser to apply the `display: none` changes
            setTimeout(() => {
                // Store original background and set to white for PDF clarity
                const originalBg = mainContentForPdf.style.backgroundColor;
                mainContentForPdf.style.backgroundColor = '#ffffff';

                // Use html2canvas to render the main content div as a canvas (image)
                html2canvas(mainContentForPdf, { scale: 2 }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png'); // Convert canvas to PNG image data
                    const pdf = new window.jsPDF('p', 'mm', 'a4'); // Initialize jsPDF for A4 portrait
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 297; // A4 height in mm
                    const imgHeight = canvas.height * imgWidth / canvas.width; // Calculate image height to maintain aspect ratio
                    let heightLeft = imgHeight;
                    let position = 0;

                    // Add the image to the PDF, handling content that spans multiple pages
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    // Save the generated PDF file with a dynamic name
                    pdf.save(`${currentQuizTopic || 'Generated'}_Quiz.pdf`);

                    // Restore original display styles and background color after PDF generation
                    originalDisplays.forEach(({ el, display }) => {
                        el.style.display = display;
                    });
                    mainContentForPdf.style.backgroundColor = originalBg;
                }).catch(error => {
                    console.error('Error generating PDF:', error);
                    displayError('Failed to download quiz. Please try again.');
                    // Ensure elements are restored even if an error occurs
                    originalDisplays.forEach(({ el, display }) => {
                        el.style.display = display;
                    });
                    mainContentForPdf.style.backgroundColor = originalBg;
                });
            }, 100); // Short delay for DOM repaint to ensure elements are hidden
        }


        // --- Event Listeners Initialization (on window load) ---
        window.onload = function() {
            // Initial state reset to ensure a clean start when the page loads
            resetQuizApp();
            initialMessage.classList.remove('hidden'); // Ensure the initial welcome message is visible

            // Event listener for the floating "Create Quiz" button click
            floatingCreateQuizBtn.addEventListener('click', () => {
                resetQuizApp(); // Reset all quiz state before opening the modal for a new quiz
                showCreateQuizModal(); // Display the modal
            });

            // Event listeners for the buttons inside the modal
            cancelQuizBtn.addEventListener('click', hideCreateQuizModal); // Hide modal on "Cancel"
            generateQuizModalBtn.addEventListener('click', generateQuestions); // Trigger quiz generation on "Generate Quiz"

            // Event listeners for quiz interaction buttons (Submit, Create New, Download)
            submitQuizBtn.addEventListener('click', handleSubmitQuiz); // Submit quiz answers
            createNewQuizBtn.addEventListener('click', () => {
                resetQuizApp();      // Reset app state
                showCreateQuizModal(); // Open modal to create a new quiz
            });
            downloadQuizBtn.addEventListener('click', downloadQuizAsPdf); // Download quiz as PDF
        };
    </script>
</body>
</html>
